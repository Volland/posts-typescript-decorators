{% extends 'base.md.j2' %}
{% block lead %}
{# This post serves as introduction to TypeScript decorators. You should have some familiarity with TypeScript and some object-oriented programing experience. #}
{% endblock %}
{% block content %}
## Decorators

[The decorator pattern](https://sourcemaking.com/design_patterns/decorator) modifies instances of existing objects without affecting the root object or siblings. Typically the pattern extends a base interface by toggling features, setting attributes, or defining roles. Instances of the object being decorated should usually be able to interact, but they don't have to have identical interfaces. Like many foundational patterns, [no one agrees about the Platonic decorator](http://wiki.c2.com/?DecoratorPattern).

TypeScript provides [experimental decorator support](https://www.typescriptlang.org/docs/handbook/decorators.html). [The ECMAScript decorator proposal](https://github.com/tc39/proposal-decorators) has reached [stage 2](https://tc39.github.io/process-document/), so we could see them in vanilla JS eventually. TypeScript provides class, method, parameter, and property decorators. Each can be used to observe the decorated objects (mentioned heavily in the docs). All but the parameter decorator can be used to modify the root object.

TypeScript decorators also provide some [mixin support](https://en.wikipedia.org/wiki/Mixin). Without true [multiple inheritance](https://en.wikipedia.org/wiki/Multiple_inheritance) in JavaScript, combining features can lead to obscenely long prototype chains. TypeScript decorators alleviate that issue by adding behavior at runtime on top of normal inheritance.

## Simple Example

First we need to define several decorators. Each signature was taken from [the official docs](https://www.typescriptlang.org/docs/handbook/decorators.html) and will be explained more later (but maybe not this post).

{% for decorator in ['ClassDecorator', 'MethodDecorator', 'ParameterDecorator', 'PropertyDecorator'] %}

{{
    highlight_block(
        "typescript/intro/decorators/%s.ts" % decorator,
        blob_path = "typescript/intro/decorators/%s.ts" % decorator,
        explicit_lexer_name = 'TypeScriptLexer',
        title = "decorators/%s.ts" % decorator,
        external_source_link = "https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/intro/decorators/%s.ts" % decorator
    )
}}

{% endfor %}

Next we'll need to consume the decorators. The decorators are placed before the object they modify, e.g. `@ClassDecorator class Foo {}`. You could use any of the decorators on any object, but you probably won't see great results unless you hit something like their intended targets. Do note that method decorators are used to modify both normal methods and `(g|s)etter` methods.

{{
    highlight_block(
        'typescript/intro/SimpleClass.ts',
        blob_path = 'typescript/intro/SimpleClass.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'SimpleClass.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/intro/SimpleClass.ts'
    )
}}

{{
    shell_session('''
$ ts-node SimpleClass.ts
Decorating property foo from SimpleClass
Decorating method bar from SimpleClass
Decorating parameter writeGreeting (index 0) from SimpleClass
Decorating method writeGreeting from SimpleClass
Decorating SimpleClass
Simple class initialized
Hello, world
''')
}}

The execution order is [explained in the docs](https://www.typescriptlang.org/docs/handbook/decorators.html#decorator-evaluation); to summarize,

1. instance parameter, method, and property decorators,
2. static parameter, method, and property decorators,
3. constructor parameter decorators, and
4. class decorators.


## Logging Example

## Decorator Factories

{% endblock %}
