{% extends 'base.md.j2' %}
{% block lead %}
{% endblock %}
{% block content %}
## Overview

Parameter decorators are the most restricted decorators, both in and out of strict mode. [The official docs](https://www.typescriptlang.org/docs/handbook/decorators.html#parameter-decorators) explicitly state

> [a] parameter decorator can only be used to observe that a parameter has been declared on a method.

Parameter decorators ignore any return, underlining their inability to affect the decorated parameters. [As we saw previously](https://blog.wizardsoftheweb.pro/typescript-decorators-reflection/#examplevalidateaparameterrange), parameter decorators can be used in tandem with other decorators to define extra information about the parameter. By themselves, their effectiveness is limited. [Logging parameter data](https://blog.wizardsoftheweb.pro/typescript-decorators-javascript-foundation/#parameterdecorators) seems to be the best use for a parameter decorator by itself.

(If you've got a different or novel use for parameter decorators, I'd love to hear about it. Seriously. I'm really curious to see how other devs are using these. My email's in the footer.)

### Class Method vs Global Function

An interesting side-effect of decorators is that they (apparently) must be defined on class elements. You can't decorate globals unattached to a class.

{{
    highlight_block(
        'typescript/parameters/overview/class-only.ts',
        blob_path = 'typescript/parameters/overview/class-only.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'class-only.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/parameters/overview/class-only.ts'
    )
}}

{{
    shell_session('''
$ ts-node class-only.ts
TargetDemo { foo1: [Function] }
foo1
1
Class method foo
Global function foo
''')
}}

Even though we've attempted to decorate the global function `foo`, it doesn't work. Notice how the decorated logging is only called once, not twice, and only with `foo1`. I suspect this is related to how all of these things are defined, and will probably be explored in another post.

## Signature

{{
    highlight_block(
        'typescript/parameters/signature/signature.ts',
        blob_path = 'typescript/parameters/signature/signature.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'signature.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/parameters/signature/signature.ts'
    )
}}

This example is used to explain the signature.

{{
    highlight_block(
        'typescript/parameters/signature/signature-example.ts',
        blob_path = 'typescript/parameters/signature/signature-example.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'signature-example.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/parameters/signature/signature-example.ts'
    )
}}

### `target: any`

`target` is the object (not method) that owns the method whose parameter has been decorated. `target` in the example is `TargetDemo`, not `foo`.

### `propertyKey: string | symbol`

`propertyKey` is the method name (not object name) whose signature has been decorated. It could also be [a `Symbol`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol), depending on how the method is defined on the object. `propertyKey` in the example is `foo`, not `TargetDemo`.

### `parameterIndex: number`

`parameterIndex` is the index of the decorated parameter in the signature of the calling method. `parameterIndex` in the example is `1`.

## Changing Mode

I haven't noticed any difference between parameter decorators in strict mode and those not in strict mode. The passed-in context doesn't seem to be the owning object, and, again, as the return is ignored, I'm not sure there's even a convoluted way to access the parameters themselves. Both are able to modify `target`, as always. The examples below just illustrate the differences between `this`; I also don't see a use for one over the other (aside from the flexibility differences in and out of strict mode, which is a different topic).

To [rehash what's happening under the hood](https://blog.wizardsoftheweb.pro/typescript-decorators-javascript-foundation/#prettifiedandpolished), parameter decorators have three parameters, so the decorator is [only called with `target` and `propertyKey`](https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/foundation/pretty/decorate.js#L35). Again, because parameter decorators have three parameters, the decorator's return is [returned from the decoration](https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/foundation/pretty/decorate.js#L50). However, as `__decorate` isn't used (e.g. [called but not assigned](https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/foundation/raw/main.js#L16)), nothing happens.

### Strict Mode

{{
    highlight_block(
        'typescript/parameters/mode/strict/tsconfig.json',
        blob_path = 'typescript/parameters/mode/strict/tsconfig.json',
        explicit_lexer_name = 'JsonLexer',
        title = 'strict/tsconfig.json',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/parameters/mode/strict/tsconfig.json'
    )
}}

{{
    highlight_block(
        'typescript/parameters/mode/strict/main.ts',
        blob_path = 'typescript/parameters/mode/strict/main.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'strict/main.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/parameters/mode/strict/main.ts'
    )
}}

{{
    shell_session("""
$ ts-node -P strict/tsconfig.json strict/main.ts
TypeError: Cannot read property 'constructor' of undefined
changed in decorator
""")
}}

As expected, nothing happens. A function's `this` is not defined [in strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode#Securing_JavaScript).

### Not Strict Mode

{{
    highlight_block(
        'typescript/parameters/mode/not-strict/tsconfig.json',
        blob_path = 'typescript/parameters/mode/not-strict/tsconfig.json',
        explicit_lexer_name = 'JsonLexer',
        title = 'not-strict/tsconfig.json',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/parameters/mode/not-strict/tsconfig.json'
    )
}}

{{
    highlight_block(
        'typescript/parameters/mode/not-strict/main.ts',
        blob_path = 'typescript/parameters/mode/not-strict/main.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'not-strict/main.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/parameters/mode/not-strict/main.ts'
    )
}}

{{
    shell_session("""
$ ts-node -P not-strict/tsconfig.json not-strict/main.ts
this.constructor.name: Object
target.constructor.name: NotStrictModeClass
this !== target
changed in decorator
""")
}}

Because the context (`this`) isn't the owning object (an instance of `target`), we don't gain a tremendous amount here by eschewing strict mode.

## Example
{% endblock %}
