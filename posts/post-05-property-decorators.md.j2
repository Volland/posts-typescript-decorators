{% extends 'base.md.j2' %}
{% block lead %}
{% endblock %}
{% block content %}
## Overview

Property decorators are very similar to [parameter decorators](https://blog.wizardsoftheweb.pro/typescript-decorators-parameter-decorators) in that they're only able to observe declarations (or rather, should only observe declarations). [The official docs](https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators) state

> a property decorator can only be used to observe that a property of a specific name has been declared for a class.

Property decorators ignore any return, underscoring their inability to affect the decorated properties. [Similar to parameter decorators](https://blog.wizardsoftheweb.pro/typescript-decorators-reflection/#examplevalidateaparameterrange), property decorators can be used in tandem with other decorators to define extra information about the property. By themselves, their effectiveness is limited. [Logging property data](https://blog.wizardsoftheweb.pro/typescript-decorators-javascript-foundation/#propertydecorators) seems to be the best use for a property decorator by itself.

A widely used antipattern is to update a property descriptor on `target` in a property decorator (if that doesn't make sense now, it should by the end of the post).

## Signature

{{
    highlight_block(
        'typescript/properties/signature/signature.ts',
        blob_path = 'typescript/properties/signature/signature.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'signature.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/properties/signature/signature.ts'
    )
}}

This example is used to explain the signature.

{{
    highlight_block(
        'typescript/properties/signature/signature-example.ts',
        blob_path = 'typescript/properties/signature/signature-example.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'signature-example.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/properties/signature/signature-example.ts'
    )
}}

### `target: any`

`target` is the object that owns the decorated property. `target` in the example is `TargetDemo`.

### `propertyKey: string | symbol`

`propertyKey` is the name of the decorated property. It could also be [a `Symbol`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol), depending on how the property is defined on the object. `propertyKey` in the example is `foo`.

## Usage

### Attach Metadata

{{
    highlight_block(
        'typescript/properties/usage/arbitrary/constants.ts',
        blob_path = 'typescript/properties/usage/arbitrary/constants.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'arbitrary/constants.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/properties/usage/arbitrary/constants.ts'
    )
}}

First we define the metadata key and `export` it for anything to `import`.

{{
    highlight_block(
        'typescript/properties/usage/arbitrary/interfaces.ts',
        blob_path = 'typescript/properties/usage/arbitrary/interfaces.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'arbitrary/interfaces.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/properties/usage/arbitrary/interfaces.ts'
    )
}}

This defines `ISinglePropertyMetadata` and `IAllPropertyMetadata` to streamline manipulation. It's usually better to have types to rely on.

{{
    highlight_block(
        'typescript/properties/usage/arbitrary/PropertyMetadata.ts',
        blob_path = 'typescript/properties/usage/arbitrary/PropertyMetadata.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'arbitrary/PropertyMetadata.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/properties/usage/arbitrary/PropertyMetadata.ts'
    )
}}

The `PropertyMetadata` decorator updates both a property's metadata name and description. It consumes an `ISinglePropertyMetadata` object to load the values.

{{
    highlight_block(
        'typescript/properties/usage/arbitrary/main.ts',
        blob_path = 'typescript/properties/usage/arbitrary/main.ts',
        explicit_lexer_name = 'TypeScriptLexer',
        title = 'arbitrary/main.ts',
        external_source_link = 'https://github.com/thecjharries/posts-typescript-decorators/blob/master/typescript/properties/usage/arbitrary/main.ts'
    )
}}

Putting everything together, we can decorate at will.

{{
    shell_session("""
$ ts-node arbitrary/main.ts
Class property metadata: undefined
Instance property metadata: { foo: { name: 'foo' },
  bar: { description: 'property bar' },
  baz: { name: 'baz', description: 'property baz' } }
""")
}}

## Recap

{% endblock %}
